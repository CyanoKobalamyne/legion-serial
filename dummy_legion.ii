#include <cstdlib>
#include <cstring>

#include "dummy_legion.hh"  // Useful for IDEs.

/* Template definitions that must be in the header. */

namespace Legion {

template <typename T,
          T (*TASK_PTR)(const Task*, const std::vector<PhysicalRegion>&,
                        Context, Runtime*)>
VariantID Runtime::preregister_task_variant(
    const TaskVariantRegistrar& registrar, const char* task_name) {
    tasks[registrar.id] = RuntimeHelperT<T, TASK_PTR>();
    return registrar.id;
}
template <void (*TASK_PTR)(const Task*, const std::vector<PhysicalRegion>&,
                           Context, Runtime*)>
VariantID Runtime::preregister_task_variant(
    const TaskVariantRegistrar& registrar, const char* task_name) {
    tasks[registrar.id] = RuntimeHelperT<void, TASK_PTR>();
    return registrar.id;
}
template <typename T,
          T (*TASK_PTR)(const Task*, const std::vector<PhysicalRegion>&,
                        Context, Runtime*)>
void* RuntimeHelperT<T, TASK_PTR>::run(
    const Task* task, const std::vector<PhysicalRegion>& regions, Context ctx,
    Runtime* rt) {
    T val = TASK_PTR(task, regions, ctx, rt);
    void* ret = std::malloc(sizeof(T));
    memcpy(ret, &val, sizeof(T));
    return ret;
}
template <void (*TASK_PTR)(const Task*, const std::vector<PhysicalRegion>&,
                           Context, Runtime*)>
void* RuntimeHelperT<void, TASK_PTR>::run(
    const Task* task, const std::vector<PhysicalRegion>& regions, Context ctx,
    Runtime* rt) {
    TASK_PTR(task, regions, ctx, rt);
    return nullptr;
}

}  // namespace Legion
